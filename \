#!/usr/bin/env node

/* --------------------------------------------------------------------- *
 | OpenKM Filesystem MCP                                                 |
 |  – navigate the OpenKM repository and read PDFs as plain text         |
 * --------------------------------------------------------------------- */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import {
	StdioServerTransport
} from "@modelcontextprotocol/sdk/server/stdio.js";
import {
	ListToolsRequestSchema,
	CallToolRequestSchema,
	ToolSchema,
} from "@modelcontextprotocol/sdk/types.js";

import fetch from "node-fetch";
import { z } from "zod";
import { zodToJsonSchema } from "zod-to-json-schema";
import { getDocument } from "pdfjs-dist/legacy/build/pdf.mjs";

/* ---------- 1.  Environment & helper -------------------------------- */

const {
	OKM_BASE_URL = "http://localhost:9090/OpenKM",
	OKM_USER = "okmAdmin",
	OKM_PASS = "admin",
} = process.env;

function okmHeaders(overrideHeaders: Record<string, string> = {}) {
	const auth = Buffer.from(`${OKM_USER}:${OKM_PASS}`).toString("base64");
	return {
		Authorization: `Basic ${auth}`,
		Accept: "application/json", // Default Accept header
		...overrideHeaders
	};
}

async function okmGet(path: string, qs: Record<string, string> = {}, overrideHeaders: Record<string, string> = {}) {
	const url = new URL(`${OKM_BASE_URL}${path}`);
	for (const [k, v] of Object.entries(qs)) url.searchParams.append(k, v);
	const res = await fetch(url, { headers: okmHeaders(overrideHeaders) });
	if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
	return res;
}

/* ---------- 2.  Zod argument schemas -------------------------------- */

const ListDirArgs = z.object({ path: z.string() });
const ReadFileArgs = z.object({
	docID: z.string().describe("The path of the document, with backslashes removed only forward slashes are allowed"),
	page_range: z.string().optional().describe("OpenKM page syntax e.g. 1,3-5,-1 (Note: currently not used for PDF text extraction in this version)") // Added a note about page_range
});
const SearchDocsArgs = z.object({
	query: z.string(),
	limit: z.number().int().positive().max(100).default(10)
});
const GetMetaArgs = z.object({ path: z.string() });

type ListDirParams = z.infer<typeof ListDirArgs>;
type ReadFileParams = z.infer<typeof ReadFileArgs>;
type SearchDocsParams = z.infer<typeof SearchDocsArgs>;
type GetMetaParams = z.infer<typeof GetMetaArgs>;

const ToolInputSchema = ToolSchema.shape.inputSchema;
type ToolInput = z.infer<typeof ToolInputSchema>;

/* ---------- 3.  MCP server instance --------------------------------- */

const server = new Server(
	{ name: "openkm-filesystem", version: "1.0.0" },
	{ capabilities: { tools: {} } }
);

/* ---------- 4.  List‑tools handler (metadata) ----------------------- */

server.setRequestHandler(ListToolsRequestSchema, async () => ({
	tools: [
		{
			name: "list_directory",
			description:
				"List immediate children (files & folders) under an OpenKM repository path. "
				+ "Each item includes `name`, full `path`, and `isFolder`.",
			inputSchema: zodToJsonSchema(ListDirArgs) as ToolInput,
		},
		{
			name: "read_file",
			description:
				"Return the document contents of `docID`. "
				+ "• If it’s a PDF, this server attempts to extract and return its UTF‑8 text content. " // Updated description
				+ "• If it’s other text, returns that text. "
				+ "• Else returns Base‑64 (with MIME type).",
			inputSchema: zodToJsonSchema(ReadFileArgs) as ToolInput,
		},
		{
			name: "search_documents",
			description:
				"Full‑text search across OpenKM. Returns up to `limit` hits with `path`, "
				+ "`docId`, and a short `excerpt` highlighting the match.",
			inputSchema: zodToJsonSchema(SearchDocsArgs) as ToolInput,
		},
		{
			name: "get_metadata",
			description:
				"Retrieve metadata (size, author, created, modified, keywords, etc.) for "
				+ "a document or folder at the given repository `path`.",
			inputSchema: zodToJsonSchema(GetMetaArgs) as ToolInput,
		},
	],
}));

/* ---------- 5.  Call‑tool handler ----------------------------------- */

server.setRequestHandler(CallToolRequestSchema, async (req) => {
	const { name, arguments: args } = req.params;

	try {
		/* ---- list_directory ------------------------------------------- */
		if (name === "list_directory") {
			const { path } = ListDirArgs.parse(args) as ListDirParams;
			const res = await okmGet("/services/rest/document/getChildren", {
				fldId: path,
			});
			const items = await res.json() as any[];
			const listing = items.map((it: any) => ({
				name: it.title,
				path: it.path,
				isFolder: it.folder,
			}));

			return { content: [{ type: "json", json: listing }] };
		}

		/* ---- read_file ------------------------------------------------ */
		if (name === "read_file") {
			// The 'page_range' argument is parsed but not yet used in this implementation.
			// Text extraction currently processes the entire PDF.
			const { docID /*, page_range */ } = ReadFileArgs.parse(args) as ReadFileParams;

			// 1) Get the document content.
			// Request as octet-stream to handle all types initially as a buffer.
			const fileResponse = await okmGet("/services/rest/document/getContent", {
				docID: docID,
				inline: "true", // This may help ensure correct Content-Type from some servers
			}, { Accept: "application/octet-stream" }); // Explicitly request octet-stream

			// Extract MIME type, removing potential charset, e.g., "application/pdf;charset=UTF-8" -> "application/pdf"
			const fileMimeType = fileResponse.headers.get("content-type")?.split(';')[0].trim() ?? "application/octet-stream";
			const fileBuffer = Buffer.from(await fileResponse.arrayBuffer());

			if (fileMimeType.startsWith("text/")) {
				return { content: [{ type: "text", text: fileBuffer.toString("utf8") }] };
			} else if (fileMimeType === "application/pdf") {
				try {
					const text = await extractText(fileBuffer);

					return { content: [{ type: "text", text: text }] };
				} catch (pdfError) {
					const errorMessage = pdfError instanceof Error ? pdfError.message : String(pdfError);
					console.error(`Error parsing PDF (docID: ${docID}):`, errorMessage);
					return {
						content: [{
							type: "text",
							text: `Error extracting text from PDF (docID: ${docID}). Details: ${errorMessage}`,
						}],
						isError: true,
					};
				}
			} else {
				// Fallback to Base‑64 for other binary types
				return {
					content: [{
						type: "text",
						text: fileBuffer.toString("base64"),
						mimeType: fileMimeType // Include the original MIME type
					}],
				};
			}
		}

		/* ---- search_documents ---------------------------------------- */
		type QueryResult = {
			queryResult: Array<Hit>;
		};
		type Hit = {
			attachment: boolean;
			excerpt: string;
			node: {
				path: string;
				uuid: string;
				// … autres champs omis
			};
			score: number;
		};

		if (name === "search_documents") {
			const { query, limit } = SearchDocsArgs.parse(args) as SearchDocsParams;

			// Appel à l’API OKM
			const res = await okmGet("/services/rest/search/findByContent", {
				content: query
			});
			const payload = (await res.json()) as QueryResult;
			// On slice après coup pour respecter le limit
			const out = (payload.queryResult || [])
				.slice(0, limit)
				.map((hit: Hit) =>
					`path: ${hit.node.path}\n` +
					`docId: ${hit.node.uuid}\n` +
					`excerpt: ${hit.excerpt}\n`
				).join("\n");

			return {
				content: [
					{
						type: "text",
						text: out,
					}
				]
			};
		}
		/* ---- get_metadata -------------------------------------------- */
		if (name === "get_metadata") {
			const { path } = GetMetaArgs.parse(args) as GetMetaParams;
			const res = await okmGet("/services/rest/document/getProperties", {
				docPath: path,
			});
			const meta = await res.json();
			return { content: [{ type: "json", json: meta }] };
		}

		throw new Error(`Unknown tool: ${name}`);

	} catch (err) {
		const msg = err instanceof Error ? err.message : String(err);
		console.error(`Error in tool ${name}:`, msg); // Log the error server-side as well
		return {
			content: [{ type: "text", text: `Error: ${msg}` }],
			isError: true,
		};
	}
});

/* ---------- 6.  Helpers         ----------------------------------- */
async function extractText(fileBuffer: Buffer): Promise<string> {
	const loadingTask = getDocument(fileBuffer);
	const pdf = await loadingTask.promise;
	let fullText = "";
	for (let i = 1; i <= pdf.numPages; i++) {
		const page = await pdf.getPage(i);
		const { items } = await page.getTextContent()
		fullText += items.map(i => ('str' in i ? i.str : '')).join(' ') + '\n\n';
	}
	return fullText;
}
/* ---------- 7.  Boot the server ------------------------------------ */

(async () => {
	const transport = new StdioServerTransport();
	await server.connect(transport);
	console.error("OpenKM Filesystem MCP ready (stdio transport)");
})();
